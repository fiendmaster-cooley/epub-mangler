import { readFileSync, readFile } from "fs";
import JSZip, { JSZipObject } from "jszip";
import type Epub from "../../src/components/Epub";
import EpubService from "../../src/components/EpubService";
const jsdom = require("jsdom");
const { JSDOM } = jsdom;
//load an epub from buffer
//
describe("Test epub service", () => {
  const FILE_NAME_AUTHOR = "OEBPS/about-the-author.xhtml";
  const FILE_NAME_ALSO = "OEBPS/also-by.xhtml";

  const valid_epub_path =
    "/Users/paul/Documents/dev/epub_resource/tests/unit/TestValidEbook/Generic/";
  const epub_file_name = "TestValidEbook-Generic.epub";

  let validEpubFile: Epub;

  const bufferToBufferArray = (path: string) => {
    const theBuffer = readFileSync(path);
    const arrayBuffer = new ArrayBuffer(theBuffer.length);
    const view = new Uint8Array(arrayBuffer);
    for (let i = 0; i < theBuffer.length; ++i) {
      view[i] = theBuffer[i];
    }
    return arrayBuffer;
  };
  /**
   * this intrinsically tests the createepub
   */
  beforeEach(async () => {
    const zip = new JSZip();

    const arrayBuffer = bufferToBufferArray(valid_epub_path + epub_file_name);

    //should have the array now.

    const sourceZip = await zip.loadAsync(arrayBuffer);
    validEpubFile = await EpubService.createEpub(epub_file_name, sourceZip);
  });

  test("Generate epub files", async () => {
    const statusLogger = async (message: string) => {};
    await EpubService.generateEpub(
      validEpubFile,
      "/Users/paul/generateEpubfilesTest.epub",
      (message: string) => {},
    );
  });

  /**
  This should search through content.opf, toc, and contents.xhtml to replace references to old file to new file.
  *
  */

  //"Replace file function"

  test("Replace file function", async () => {
    //we want to replace an existing file in the epub with a new document
    //once replaced, we'll deserialize from the sourcezip
    //and compare the file.
    console.debug("Path:\t" + process.cwd());
    //first things first. get the original file.
    const replacementBuffer = bufferToBufferArray(
      process.cwd() + "/tests/unit/alsoByNewContents.xhtml",
    );
    const decoder = new TextDecoder();
    const replacementXML = decoder.decode(replacementBuffer);
    console.debug("result:\t" + replacementXML);
    const xmlDocReplacement = new JSDOM(replacementXML, {}).window.document;
    if (xmlDocReplacement.getElementsByTagName("html").length === 0) {
      throw new Error("Xml doc was undefined, null, or some other problem");
    }
    //now we call the epubService
    const modifiedEpub: Epub = await EpubService.replaceFile(
      validEpubFile,
      FILE_NAME_ALSO,
      xmlDocReplacement,
      async (message: string) => {},
    );
    // now we want to get the modified epub again
    // get the file again from the new zip
    // and compare the strings.
    const newJS = modifiedEpub.sourceZip.file(FILE_NAME_ALSO);
    const newJSText = await newJS!.async("string");

    const newNode = new JSDOM(newJSText, {}).window.document;

    expect(newJSText.indexOf("Generated by ReplaceFile test")).toBeGreaterThan(
      -1,
    );
  });

  test("Replace file references", async () => {
    const replacementBuffer = bufferToBufferArray(
      process.cwd() + "/tests/unit/also-by.xhtml",
    );
    const decoder = new TextDecoder();
    const replacementXMLText: string = decoder.decode(replacementBuffer);
    const getFile = async (theEpubFile: Epub, name: string) => {
      const thefile = theEpubFile.sourceZip.file(name);
      expect(thefile).toBeDefined();
      expect(thefile!.name.localeCompare(name)).toBe(0);
      return thefile;
    };

    const sourceTOC = getFile(validEpubFile, "OEBPS/toc.ncx");
    const sourceContentOPF = getFile(validEpubFile, "OEBPS/content.opf");
    const sourceXMLText = getFile(validEpubFile, "OEBPS/also-by.xhtml");

    const findAllOccurrences = (str: string, substr: string) => {
      str = str.toLowerCase();
      let result = [];
      let idx: number = str.indexOf(substr);
      while (idx !== -1) {
        //@ts-ignore
        result.push(idx);
        idx = str.indexOf(substr, idx + 1);
      }
      return result;
    };
    const sourceNumberOfReferencesXHTML = findAllOccurrences(
      "" + sourceXMLText,
      "also-by.xhtml",
    );
    const tocSourceReferences = findAllOccurrences(
      "" + sourceTOC,
      "also-by.xhtml",
    );
    const opfSourceReferences = findAllOccurrences(
      "" + sourceContentOPF,
      "also-by.xhtml",
    );
    console.debug(sourceNumberOfReferencesXHTML);
    console.debug(tocSourceReferences);
    console.debug(opfSourceReferences);
    const statusCallback = async (
      message: string,
      level: string,
      severity: string,
    ) => {
      //do nothing...
    };

    const fileToFix = "about-the-author.xhtml";
    const newName = "about-paul-e-cooley.xhtml";
    const fixedEpub = await EpubService.replaceFileReferences(
      validEpubFile,
      fileToFix,
      newName,
      statusCallback,
    );
    const fixedFile = fixedEpub.sourceZip.file(newName);
    expect(fixedFile).not.toBe(null);
    expect(fixedFile!.name.localeCompare(newName)).toBe(0);
    //now get the files from the valid epub...
    const fixedTOC = await getFile(fixedEpub, "OEBPS/toc.ncx");
    const fixedOPF = await getFile(fixedEpub, "OEBPS/content.opf");
    const fixedTOCValue = await fixedTOC!.async("string");
    const fixedOPFValue = await fixedOPF!.async("string");
    expect(findAllOccurrences(fileToFix, fixedTOCValue)).toBe(0);
    expect(findAllOccurrences(fileToFix, fixedOPFValue)).toBe(0);
  });

  test("Simple regex test", () => {
    //load the also-by.xhtmn
    const theSTring = "";
  });
});
